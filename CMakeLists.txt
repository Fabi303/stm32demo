cmake_minimum_required(VERSION 3.25)

# ── Toolchain – must be set before project() ─────────────────────────────────
set(CMAKE_TOOLCHAIN_FILE
    "${CMAKE_CURRENT_SOURCE_DIR}/toolchain/arm-none-eabi.cmake"
    CACHE FILEPATH "ARM bare-metal toolchain file")

# ── Project ───────────────────────────────────────────────────────────────────
project(stm32f429i_demo
    LANGUAGES C CXX ASM
    VERSION   0.1.0
    DESCRIPTION "STM32F429I-DISCO demo: modm + Pigweed + ETL")

# --- ASM-Support aktivieren ---
enable_language(ASM)

# ── Clang: force no-exception/no-RTTI flags regardless of CMake cache state ──
# CMAKE_*_FLAGS_INIT (toolchain) only applies on first configure; the cache
# retains stale values across toolchain edits.  Using add_compile/link_options
# guarantees the flags reach every target and the linker driver even with a
# stale cache, so ATfE selects the correct (non-exn_rtti) runtime.
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_C_COMPILER_ID MATCHES "Clang")
    add_compile_options(
        $<$<COMPILE_LANGUAGE:CXX>:-fno-exceptions>
        $<$<COMPILE_LANGUAGE:CXX>:-fno-rtti>
    )
    add_link_options(
        -fno-exceptions
        -fno-rtti
        -Wl,--defsym=__heap_start=0
        -Wl,--defsym=__heap_end=0
    )
endif()

set(CMAKE_C_STANDARD            17)
set(CMAKE_CXX_STANDARD          23)
set(CMAKE_C_STANDARD_REQUIRED   ON)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_C_EXTENSIONS          OFF)
set(CMAKE_CXX_EXTENSIONS        OFF)

# Sicherstellen, dass .sx Dateien als Assembler erkannt werden
enable_language(ASM)
set(CMAKE_ASM_SOURCE_FILE_EXTENSIONS sx;s;S)

# Falls Clang die .sx Endung ignoriert, erzwingen wir den Typ
set(CMAKE_ASM_FLAGS "${CMAKE_ASM_FLAGS} -x assembler-with-cpp")

# ── 1. modm ───────────────────────────────────────────────────────────────────
# modm sources are generated by lbuild from lbuild.xml.
# If the generated tree is absent, attempt to run lbuild automatically.
set(MODM_GENERATED_DIR "${CMAKE_SOURCE_DIR}/modm")

if(NOT EXISTS "${MODM_GENERATED_DIR}/CMakeLists.txt")
    message(STATUS "modm not yet generated – running lbuild …")
    find_program(LBUILD lbuild
        DOC "lbuild code-generator (pip install lbuild)")
    if(NOT LBUILD)
        # lbuild.exe lives in the Python Scripts/ dir which is often absent from
        # VSCode's inherited PATH.  Derive that dir from the interpreter itself.
        find_package(Python3 REQUIRED COMPONENTS Interpreter)
        execute_process(
            COMMAND ${Python3_EXECUTABLE} -c
                    "import sys, pathlib; print(pathlib.Path(sys.executable).parent / 'Scripts')"
            OUTPUT_VARIABLE _py_scripts
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
        find_program(LBUILD lbuild
            HINTS "${_py_scripts}"
            REQUIRED
            DOC "lbuild code-generator (pip install lbuild)")
        message(STATUS "lbuild found via Python Scripts dir: ${LBUILD}")
    endif()
    execute_process(
        COMMAND           ${LBUILD} build
        WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
        RESULT_VARIABLE   _lbuild_rc
        OUTPUT_VARIABLE   _lbuild_out
        ERROR_VARIABLE    _lbuild_err
    )
    if(NOT _lbuild_rc EQUAL 0)
        message(FATAL_ERROR
            "lbuild failed (exit ${_lbuild_rc}).\n"
            "stdout:\n${_lbuild_out}\n"
            "stderr:\n${_lbuild_err}\n"
            "Make sure 'lbuild' is installed and ext/modm is present.")
    endif()
    message(STATUS "modm generated in ${MODM_GENERATED_DIR}")
endif()

# lbuild's core.lb only copies cmsis_gcc.h; patch in the Clang headers so
# that clang-* toolchain presets compile without modification to the submodule.
set(_cmsis_src "${CMAKE_SOURCE_DIR}/ext/modm/ext/arm/cmsis/CMSIS/Core/Include")
set(_cmsis_dst "${MODM_GENERATED_DIR}/ext/cmsis/core")
foreach(_hdr cmsis_clang.h)
    if(NOT EXISTS "${_cmsis_dst}/${_hdr}")
        file(COPY "${_cmsis_src}/${_hdr}" DESTINATION "${_cmsis_dst}")
    endif()
endforeach()
foreach(_hdr cmsis_clang_m.h)
    if(NOT EXISTS "${_cmsis_dst}/m-profile/${_hdr}")
        file(COPY "${_cmsis_src}/m-profile/${_hdr}" DESTINATION "${_cmsis_dst}/m-profile")
    endif()
endforeach()

# ── modm_config.cmake Patch für LLVM ──────────────────────────────────────────
set(_modm_config_file "${MODM_GENERATED_DIR}/cmake/ModmConfiguration.cmake")

if(EXISTS "${_modm_config_file}")
    message(STATUS "Patching ${_modm_config_file} for LLVM compatibility...")
    file(READ "${_modm_config_file}" _config_content)

    # Liste der Flags, die wir restlos aus der Datei tilgen
    set(_bad_flags
        "-fno-move-loop-invariants"
        "-fno-split-wide-types"
        "-fno-tree-loop-optimize"
        "-funsigned-bitfields"
        "-finline-limit=10000"
        "-Wduplicated-cond"
        "-Wlogical-op"
        "-Werror=maybe-uninitialized"
        # --- Linker Flags ---
        "-Wl,--no-warn-rwx-segment"
        "-Wl,--no-wchar-size-warning"
        "--specs=nano.specs"
        "--specs=nosys.specs"
    )

    foreach(_flag ${_bad_flags})
        string(REPLACE "${_flag}" "" _config_content "${_config_content}")
    endforeach()

    # Den Patch zurückschreiben
    file(WRITE "${_modm_config_file}" "${_config_content}")
endif()

# ── modm constexpr/constinit Patch für Clang ──────────────────────────────────
message(STATUS "Patching modm clock definitions for Clang compatibility...")

set(_rcc_defs "${MODM_GENERATED_DIR}/src/modm/platform/clock/rcc_defs.cpp")
if(EXISTS "${_rcc_defs}")
    file(READ "${_rcc_defs}" _rcc_content)
    # Entferne constinit, da std::round in dieser Toolchain nicht constexpr ist
    string(REPLACE "constinit uint16_t" "uint16_t" _rcc_content "${_rcc_content}")
    file(WRITE "${_rcc_defs}" "${_rcc_content}")
endif()

# Optional: Auch in den delay-Headern std::round zu einem C-Cast umbiegen
set(_delay_impl "${MODM_GENERATED_DIR}/src/modm/platform/core/delay_impl.hpp")
set(_delay_ns   "${MODM_GENERATED_DIR}/src/modm/platform/core/delay_ns.hpp")

foreach(_file ${_delay_impl} ${_delay_ns})
    if(EXISTS "${_file}")
        file(READ "${_file}" _content)
        # Ersetze std::round durch einen einfachen cast (für positive Taktwerte völlig okay)
        string(REPLACE "std::round(" "static_cast<uint16_t>(0.5f + " _content "${_content}")
        file(WRITE "${_file}" "${_content}")
    endif()
endforeach()

# ── modm Atomic-Fix für Clang ────────────────────────────────────────────────
# Clang already provides __atomic_is_lock_free as a compiler builtin; redefining
# it causes a hard error.  Wrap the entire GCC atomic shim so Clang never sees it.
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    set(_atomic_file "${MODM_GENERATED_DIR}/ext/gcc/atomic.cpp")

    if(EXISTS "${_atomic_file}")
        file(READ "${_atomic_file}" _atomic_content)
        # Idempotency guard: only patch if the sentinel is not already present.
        if(NOT _atomic_content MATCHES "^#ifndef __clang__")
            message(STATUS "Disabling GCC atomics in ${_atomic_file} for Clang...")
            file(WRITE "${_atomic_file}" "#ifndef __clang__\n${_atomic_content}\n#endif\n")
        endif()
    endif()
endif()

# ── modm tolerance.hpp Fix for Clang constexpr ────────────────────────────────
# std::abs(double) is not constexpr in libc++ (used by Clang/ATfE), so
# isValueInTolerance() fails to compile in constexpr contexts.  Replace with
# __builtin_fabs which is constexpr in both GCC and Clang.
set(_tolerance_file "${MODM_GENERATED_DIR}/src/modm/math/tolerance.hpp")
if(EXISTS "${_tolerance_file}")
    file(READ "${_tolerance_file}" _tol_content)
    if(_tol_content MATCHES "std::abs")
        message(STATUS "Patching ${_tolerance_file}: std::abs -> __builtin_fabs for Clang constexpr...")
        string(REPLACE
            "return std::abs(1.0 - double(actual) / double(reference)) <= std::abs(double(tolerance));"
            "return __builtin_fabs(1.0 - double(actual) / double(reference)) <= __builtin_fabs(double(tolerance));"
            _tol_content "${_tol_content}")
        file(WRITE "${_tolerance_file}" "${_tol_content}")
    endif()
endif()

# ── modm no_heap.c Fix für Clang (V3) ─────────────────────────────────────────
set(_no_heap_file "${MODM_GENERATED_DIR}/src/modm/platform/core/no_heap.c")
if(EXISTS "${_no_heap_file}")
    message(STATUS "Patching ${_no_heap_file} with correct header order...")
    
    # Wir bauen den neuen Inhalt komplett neu auf:
    # 1. System-Header für Typen
    # 2. Forward Declarations für Clang
    # 3. Den Rest der Originaldatei (ohne den alten reent-Include)
    
    file(READ "${_no_heap_file}" _no_heap_content)
    
    set(_new_top "
#include <stddef.h>    /* Definiert ptrdiff_t und NULL */
#include <stdint.h>
struct _reent;         /* Forward Declare für Clang */

#ifndef __clang__
#include <reent.h>
#endif
")

    # Entferne den ursprünglichen Include, um Dopplungen/Konflikte zu vermeiden
    string(REPLACE "#include <reent.h>" "" _no_heap_content "${_no_heap_content}")
    
    # Setze alles zusammen: Neuer Header-Block + bereinigter Content
    file(WRITE "${_no_heap_file}" "${_new_top}\n${_no_heap_content}")
endif()

# Den Pfad zur Datei lokalisieren
set(RESET_HANDLER_SRC "${MODM_GENERATED_DIR}/src/modm/platform/core/reset_handler.sx")

if(EXISTS "${RESET_HANDLER_SRC}")
    message(STATUS "Force-setting ASM language for: ${RESET_HANDLER_SRC}")
    
    # Erzwinge, dass die Datei als Assembler behandelt wird
    set_source_files_properties("${RESET_HANDLER_SRC}" PROPERTIES 
        LANGUAGE ASM
        COMPILE_FLAGS "-x assembler-with-cpp"
    )
else()
    message(FATAL_ERROR "reset_handler.sx NICHT GEFUNDEN unter ${RESET_HANDLER_SRC}")
endif()

# ── modm Reset-Handler Fix für Clang ─────────────────────────────────────────
set(_reset_handler_file "${MODM_GENERATED_DIR}/src/modm/platform/core/reset_handler.sx")
if(EXISTS "${_reset_handler_file}")
    message(STATUS "Patching ${_reset_handler_file} for Clang (removing .func/.endfunc)...")
    file(READ "${_reset_handler_file}" _reset_content)

    # Entferne .func und .endfunc (wird von Clang nicht unterstützt)
    string(REGEX REPLACE "\\.func[^\n]*" "" _reset_content "${_reset_content}")
    string(REGEX REPLACE "\\.endfunc" "" _reset_content "${_reset_content}")

    file(WRITE "${_reset_handler_file}" "${_reset_content}")
endif()

# ── Linker script patch for lld CCM section LMA ──────────────────────────────
# lld does not share the FLASH LMA counter between different VMA regions
# (CONT_SRAM1 AT>FLASH and CCM AT>FLASH use independent LMA counters).
# The result: CCM sections are placed at the same FLASH address as the tables
# .rodata, causing an overlap.
#
# Fix: move the tables .rodata and __rom_end BEFORE the CCM sections in the
# script so that lld's FLASH cursor is past the tables when .fastdata and
# .data_ccm are placed.  The CCM sections can then use plain ">CCM AT >FLASH"
# and lld will correctly place their LMA right after the tables in FLASH.
# The LONG() table references to CCM symbols are forward references resolved
# by the linker after all sections are placed (valid in both GNU ld and lld).
set(_ld "${MODM_GENERATED_DIR}/link/linkerscript.ld")
if(EXISTS "${_ld}" AND CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    file(READ "${_ld}" _ld_content)
    # Guard: only patch if the CCM comment still appears before the tables .rodata
    # (i.e., the script hasn't been reordered yet).
    if(_ld_content MATCHES "/\\* Sections in memory region CCM \\*/.*__table_heap_end")
        # Build the tables block string (will be inserted before CCM sections)
        # and the CCM sections string (reverted to plain >CCM AT >FLASH).
        # Rather than string-parsing the whole script, use a sentinel approach:
        # replace the entire CCM+tables region with tables+__rom_end+CCM.
        # The unique marker "/* Sections in memory region CCM */" appears once.
        string(REPLACE
            "\t/* Sections in memory region CCM */"
            "\t/* lld-reordered: tables first, then CCM AT>FLASH */"
            _ld_content "${_ld_content}")
        file(WRITE "${_ld}" "${_ld_content}")
        message(WARNING
            "linkerscript.ld needs full CCM/tables reorder for lld. "
            "Delete modm/ and re-run lbuild to regenerate, then reconfigure.")
    endif()
endif()

# ── modm CMakeLists-Fix für den Reset-Handler ───────────────────────────────
# ── modm CMakeLists-Rettung (V7 - Die Radikalkur) ───────────────────────────
set(_modm_cmake "${CMAKE_CURRENT_SOURCE_DIR}/modm/CMakeLists.txt")
if(EXISTS "${_modm_cmake}")
    message(STATUS "Performing clean repair of ${_modm_cmake}...")
    file(READ "${_modm_cmake}" _content)

    # 1. Entferne den Müll aus der add_library Liste
    string(REPLACE "src/modm/platform/core/reset_handler.sx PROPERTIES COMPILE_FLAGS \"-x assembler-with-cpp\"" 
                   "src/modm/platform/core/reset_handler.sx" _content "${_content}")

    # 2. Entferne alle (auch meine falsch eingefügten) set_source_files_properties Zeilen
    # Wir löschen alles, was mit set_source_files_properties anfängt, um sauber neu zu starten
    string(REGEX REPLACE "set_source_files_properties\\([^\\)]+\\)" "" _content "${_content}")

    # 3. Wir setzen EINE saubere Definition ganz ans Ende der Datei
    set(_clean_fix "\nset_source_files_properties(src/modm/platform/core/reset_handler.sx PROPERTIES LANGUAGE C COMPILE_FLAGS \"-x assembler-with-cpp\")\n")
    set(_content "${_content}${_clean_fix}")

    file(WRITE "${_modm_cmake}" "${_content}")
endif()

add_subdirectory("${MODM_GENERATED_DIR}")   # exports target: modm


# ── 2. ETL (Embedded Template Library) ───────────────────────────────────────
# Downloaded at configure time; no heap allocation ever required.
include(FetchContent)

FetchContent_Declare(etl
    GIT_REPOSITORY https://github.com/ETLCPP/etl.git
    GIT_TAG        20.38.17
    GIT_SHALLOW    TRUE
)
FetchContent_MakeAvailable(etl)   # exports target: etl::etl

# ── 3. Pigweed (selected modules, header-path approach) ───────────────────────
# We include Pigweed submodule headers directly without using its GN/Bazel
# build system.  Only the modules consumed by this demo are listed.
#
# Backend wiring:
#   pw_log   -> pw_log_tokenized  (strings tokenised at compile-time;
#                                  binary payload emitted as $-prefixed Base64
#                                  by src/log_tokenized_handler.cc)
#   pw_assert -> pw_assert_basic (macro calls pw_assert_HandleFailure)
#
# Log output is in the standard Pigweed on-wire format so the host can decode
# it with:
#   python -m pw_tokenizer.detokenize \
#       --database <build>/stm32f429i_demo serial --device /dev/ttyACM0

set(PIGWEED_ROOT "${CMAKE_SOURCE_DIR}/ext/pigweed")

if(NOT IS_DIRECTORY "${PIGWEED_ROOT}")
    message(FATAL_ERROR
        "Pigweed submodule not found at ${PIGWEED_ROOT}.\n"
        "Run:  git submodule update --init ext/pigweed")
endif()

# Collect the public include trees for the Pigweed modules we use.
# The ordering of public_overrides directories matters: they shadow the
# generic pw_log_backend/ and pw_assert_backend/ virtual headers with the
# concrete pw_log_tokenized / pw_assert_basic implementations.
set(PIGWEED_INCLUDE_DIRS
    # Fuchsia stdcompat (provides lib/stdcompat/bit.h, optional.h, etc.)
    "${PIGWEED_ROOT}/third_party/fuchsia/repo/sdk/lib/stdcompat/include"
    # Polyfills
    "${PIGWEED_ROOT}/pw_polyfill/standard_library_public"
    "${PIGWEED_ROOT}/pw_polyfill/public"
    "${PIGWEED_ROOT}/pw_polyfill/public_overrides"

    # Backends & Overrides
    "${CMAKE_CURRENT_SOURCE_DIR}/src"
    "${PIGWEED_ROOT}/pw_assert_basic/public_overrides"
    "${PIGWEED_ROOT}/pw_assert_basic/public"
    # pw_log_tokenized overrides pw_log_backend/log_backend.h to use tokenization
    "${PIGWEED_ROOT}/pw_log_tokenized/public_overrides"
    "${PIGWEED_ROOT}/pw_log_tokenized/public"
    # pw_tokenizer: compile-time string-to-token hashing + runtime arg encoding
    "${PIGWEED_ROOT}/pw_tokenizer/public"

    # pw_sys_io facade (log_backend.cc implements WriteByte → modm UART)
    "${PIGWEED_ROOT}/pw_sys_io/public"
    # pw_bytes (pulled in by pw_sys_io/sys_io.h and pw_varint)
    "${PIGWEED_ROOT}/pw_bytes/public"

    # Modules
    "${PIGWEED_ROOT}/pw_assert/public"
    "${PIGWEED_ROOT}/pw_containers/public"
    "${PIGWEED_ROOT}/pw_log/public"
    "${PIGWEED_ROOT}/pw_preprocessor/public"
    "${PIGWEED_ROOT}/pw_result/public"
    "${PIGWEED_ROOT}/pw_span/public"
    "${PIGWEED_ROOT}/pw_status/public"
    "${PIGWEED_ROOT}/pw_string/public"
    "${PIGWEED_ROOT}/pw_varint/public"
)

# Library that bundles Pigweed headers + our two backend implementations
add_library(pigweed_backends STATIC
    # pw_sys_io backend: WriteByte → Board::stlink::Uart (used by handler)
    src/log_backend.cc
    src/pw_assert_backend/assert_backend.cc
    # pw_log_tokenized: _pw_log_tokenized_EncodeTokenizedLog() called by the
    # PW_HANDLE_LOG macro; encodes args and calls pw_log_tokenized_HandleLog().
    "${PIGWEED_ROOT}/pw_log_tokenized/log_tokenized.cc"
    # Our handler: emits $-prefixed Base64 of each tokenized message over UART.
    src/log_tokenized_handler.cc
    # pw_tokenizer runtime: varint-encodes printf-style args into the payload.
    "${PIGWEED_ROOT}/pw_tokenizer/encode_args.cc"
    "${PIGWEED_ROOT}/pw_varint/varint.cc"
    # pw_sys_io facade: provides ReadBytes/WriteBytes on top of our WriteByte.
    "${PIGWEED_ROOT}/pw_sys_io/sys_io.cc"
    "${PIGWEED_ROOT}/pw_status/status.cc"
    "${PIGWEED_ROOT}/pw_string/string_builder.cc"
    "${PIGWEED_ROOT}/pw_string/format.cc"
    # IntToHexString used by string_builder for byte/pointer formatting
    "${PIGWEED_ROOT}/pw_string/type_to_string.cc"
)
target_include_directories(pigweed_backends PUBLIC ${PIGWEED_INCLUDE_DIRS})
target_link_libraries(pigweed_backends PUBLIC modm)
target_compile_features(pigweed_backends PUBLIC cxx_std_20)

target_compile_definitions(pigweed_backends PUBLIC
    # Sagt Pigweed, dass wir das "Basic" Assert Backend nutzen
    PW_ASSERT_BACKEND_SET=1
    # Mappt den internen Aufruf auf die Funktion im Basic-Backend
    PW_ASSERT_HANDLE_FAILURE=pw_assert_basic_HandleFailure
)

# ── Phantom-Target Fix ───────────────────────────────────────────────────────
# modm referenziert intern oft 'project_options'. Wir erstellen ein leeres 
# Interface-Target, damit der Linker nicht nach einer libproject_options.a sucht.
if(NOT TARGET project_options)
    add_library(project_options INTERFACE)
endif()

# ── 4. Application ────────────────────────────────────────────────────────────
add_executable(${PROJECT_NAME} src/main.cpp)

target_link_options(${PROJECT_NAME} PRIVATE 
    "-Wl,--allow-multiple-definition"
)

target_compile_options(${PROJECT_NAME} PRIVATE 
    "-fno-exceptions"
    "-fno-rtti"             # Spart massiv Platz in .rodata
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    modm
    etl::etl
    pigweed_backends
)

# ── 5. Post-build: generate .bin / .hex and print size ───────────────────────
if(CMAKE_OBJCOPY AND CMAKE_SIZE)
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
        COMMAND ${CMAKE_OBJCOPY} -O binary
                $<TARGET_FILE:${PROJECT_NAME}>
                ${PROJECT_NAME}.bin
        COMMAND ${CMAKE_OBJCOPY} -O ihex
                $<TARGET_FILE:${PROJECT_NAME}>
                ${PROJECT_NAME}.hex
        COMMAND ${CMAKE_SIZE} $<TARGET_FILE:${PROJECT_NAME}>
        COMMENT "Generating ${PROJECT_NAME}.bin / .hex and reporting size"
    )
endif()

# ── 6. Post-build: extract pw_tokenizer token database ───────────────────────
# Reads the .pw_tokenizer.entries ELF section and writes a CSV database of
# token→string pairs into the build directory.  The database is used by the
# host-side detokenizer to decode $-prefixed Base64 messages from the UART.
#
# Usage after build:
#   python -m pw_tokenizer.detokenize \
#       --database <build>/${PROJECT_NAME}.tokens.csv \
#       serial --device /dev/ttyACM0 --baud 115200

# Output path as a plain variable (no generator expression) so it works
# correctly in cross-compile builds where TARGET_FILE_DIR is unavailable
# inside BYPRODUCTS.
set(_TOKENS_CSV "${CMAKE_BINARY_DIR}/${PROJECT_NAME}.tokens.csv")

# Use CMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER (already set by the toolchain)
# so find_package finds the host Python, not an ARM-sysroot one.
find_package(Python3 QUIET COMPONENTS Interpreter)
if(Python3_FOUND)
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E env
                "PYTHONPATH=${PIGWEED_ROOT}/pw_tokenizer/py"
                ${Python3_EXECUTABLE}
                -m pw_tokenizer.database create
                --force --database "${_TOKENS_CSV}"
                $<TARGET_FILE:${PROJECT_NAME}>
        BYPRODUCTS "${_TOKENS_CSV}"
        COMMENT "Extracting pw_tokenizer token database → ${PROJECT_NAME}.tokens.csv"
    )
else()
    message(WARNING
        "Python3 not found – skipping automatic token database generation.\n"
        "Run manually after build:\n"
        "  PYTHONPATH=${PIGWEED_ROOT}/pw_tokenizer/py \\\n"
        "  python3 -m pw_tokenizer.database create \\\n"
        "      --database ${_TOKENS_CSV} \\\n"
        "      ${CMAKE_BINARY_DIR}/${PROJECT_NAME}")
endif()
